#!/usr/bin/env ruby

require 'gitodo'

options = Gitodo::CommandLineOptions.parse(ARGV)

def are_count_todos(count)
  (count == 1) ? "is #{count} todo" : "are #{count} todos"
end

def do_add()
  todo = ARGV.join(" ").strip
  form = Gitodo::AddTodoForm.new({ todo: todo })
  Gitodo::AddTodoCommand.call(add_form: form) do |m|
    m.fail {|_, result| puts result.message; exit 1 }
    m.pass do |val|
      puts %Q(Todo added. There #{are_count_todos(val.todo_count)} on branch `#{val.branch}`)
    end
  end
end

def do_done()
  form = Gitodo::DoneTodoForm.new({ todo_indexes: ARGV })
  Gitodo::DoneTodoCommand.call(done_form: form) do |m|
    m.fail {|_, result| puts result.message; exit 1 }
    m.pass do |val|
      puts %Q(Todo added. There #{are_count_todos(val.todo_count)} on branch `#{val.branch}`)
    end
  end
end

def do_list()
  Gitodo::ListTodoCommand.call do |m|
    m.fail {|_, result| puts result.message; exit 1 }
    m.pass do |val, result|
      message = %Q(There #{are_count_todos(val.todos.count)} on branch `#{val.branch}`)

      if (val.todos.any?)
        message << "\n"
      end

      val.todos.each_with_index do |todo, index|
        message << "\n\t[#{index+1}] #{todo}"
      end

      puts message
    end
  end
end

def do_check()
  Gitodo::ListTodoCommand.call do |m|
    m.fail {|_, result| puts result.message; exit 1 }
    m.pass do |val, result|
      if (val.todos.any?)
        puts %Q(Check failed! There #{are_count_todos(val.todos.count)} on `#{val.branch}`)
        exit 1
      end

      puts %Q(Check passed! `#{val.branch}` is clean!)
    end
  end
end

case options.command
when "add"
  do_add
when "done"
  do_done
when "list"
  do_list
when "check"
  do_check
else
  puts "Command not recognized"
  exit 1
end
